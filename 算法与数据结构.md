## 算法与数据结构

### 1. 动态规划

#### 1.1 五类背包问题

##### 1.1.1 01背包

* **问题**： 有**n件物品**和**容量为m的背包**，给出每件物品的**重量**以及**价值**，且**每种物品只有一个**，求解让装入背包的物品重量不超过背包容量且价值最大的**装法**及**总价值** 。 

* **分析**：

  **计算最大价值**：对于容量为v，且当正打算放第i件物品时，有三种情况
  
  1. 容量v比第i件物品的重量小，放不下，只能不放第i件物品，此时和容量v，放第i-1件物品的情况一样，满足
     $$
   F(i,v)=F(i-1,v)
     $$
  
  2. 容量v比第i件物品的重量大，可以放下，但选择不放，此时也和容量v，放第i-1件物品的情况一样，满足
     $$
   F(i,v)=F(i-1,v)
     $$
  
  3. 容量v比第i件物品的重量大，可以放下，选择放，此时总价值应为第i件物品的价值+容量为v-weight(i)时，放第i-1件物品的总价值一样，即
     $$
     F(i,v)=F(i-1,v-weight(i))+value(i)
     $$
     总体状态转移方程为
     $$
     F(i,v)=max{\left [F(i-1,v),F(i-1,v-weight(i))+value(i)\right ]}
     $$
  
  
  
  **计算装入方案**：构建路径矩阵，在每次选择放入时，路径矩阵置1。那么最后计算完成，对路径矩阵倒序遍历：
  
  1. 从n件物品，容量m处开始，以物品件数为序遍历路径矩阵，即找到容量m时，最后放入的物品；
  2. 当路径矩阵值为1时，即在此处放入的物品，再找到容量m-weight(i)时，最后放入的物品；
  3. 当找第0件物品时停止循环。

* **程序代码**

  ```java
  //
  public static void pack01(int space, int[] weight, int[] value){
          int[][] totalValue = new int[weight.length+1][space+1];
          int[][] path = new int[weight.length+1][space+1];
          //i是个数,j是空间
          for(int i=1;i<weight.length+1;i++){
              for(int j=1;j<space+1;j++){
                  if(weight[i-1]<=j){
                      if(totalValue[i-1][j]>totalValue[i-1][j-weight[i-1]]+value[i-1]){
                          totalValue[i][j]=totalValue[i-1][j];
                      }else {
                          totalValue[i][j] = totalValue[i - 1][j - weight[i-1]] 
                                             + value[i-1];
                          path[i][j]=1;
                      }
                  }else {
                      totalValue[i][j]=totalValue[i-1][j];
                  }
              }
          }
          System.out.println("the total value is "+totalValue[weight.length][space]);
          for(int i=weight.length,j=space;i>=0;i--) {
              if (path[i][j] == 1) {
                  System.out.println(i);
                  j = j - weight[i-1];
              }
          }
  ```

* **优化1**

  时间复杂度O(n^2)，空间复杂度O(n^2)。

  考虑到F矩阵第i次迭代时，均是和第i-1次，容量为 j 或 j - weight(i) 时的结果有关，那么如果将F构建为一个1维数组，则可以将空间复杂度降为O(n)。

  但如果还按以前的方式计算，那么第i次循环计算F(j)时，F(j-weight(i -1))已经被更新为第i次的结果。所以可以考虑倒序遍历，这样新结果不会污染旧结果。
  $$
  {
  F \leftarrow  0 \\
  for \   i \leftarrow\  1 \ to\  N\\
  	for\  j \leftarrow\  M-weight(i-1)\  to \ M\\
  		F(i,j) \leftarrow \ max{(F[i-1,j],F[i-1,j-weight(i-1)]+value(i))}
  }
  $$
  
* **优化代码**  时间复杂度O(n^2)，空间复杂度O(n)

  ```java
  public static void pack01(int space, int[] weight, int[] value){
          //优化
          int[] totalValue=new int[space+1];
          int[][] path = new int[weight.length+1][space+1];
          for(int i=1;i<weight.length+1;i++){
              for(int j=space;j>=weight[i-1];j--){
                  if(weight[i-1]<=j) {
                      if (totalValue[j] < totalValue[j - weight[i - 1]] 
                                          + value[i - 1]) {
                          totalValue[j] = totalValue[j - weight[i - 1]] 
                                          + value[i - 1];
                          path[i][j] = 1;
                      }
                  }
              }
          }
  
          System.out.println("the total value is "+totalValue[space]);
          for(int i=weight.length,j=space;i>=0;i--) {
              if (path[i][j] == 1) {
                  System.out.println(i);
                  j = j - weight[i-1];
              }
          }
  }
  ```
  
* **优化2**

  上面的解法中，F 矩阵的初始值为0，即可以理解为背包在容量为0且什么也不装时，价值为0。如果要求最后的结果是背包恰好装满，那么此时只有容量0的背包可以在什么也不装的情况下价值为0，容量为[1,2,..,m]的背包均没有合法的解。

  也就是如果题目要求最后背包必须被装满时，F的初始化也改为F(0)=0，F(i)=Integer.MIN_VALUE [i=1,2,...,m]。

###### 1.1.2 完全背包问题

* **问题：**有n件物品和容量为m的背包，给出每件物品的重量以及价值，且**每种物品有无数个**，求解让装入背包的物品重量不超过背包容量的最大总价值 。

* **分析：**物品有无数个，只需在01背包的基础上考虑，当放入某种物品时，应该放几个会使收益最大，即
  $$
  F(i,v)=max{\left[F(i-1,v-k*weight(i))+k*value(i)  \ |\ 0\leq k\leq v/weight\right ]}
  $$
也就是说，状态转移方程改写为
  $$
  F(i,v)=max{\left[F(i,v-weight(i))+value(i), F(i-1,v)\right ]}
  $$
  
* **程序代码：**

  ```java
  //这里其实只改变了内层循环的方向
  public static void completePack(int space, int[] weight, int[] value){
          int[] totalValue = new int[space+1];
          for(int i=1;i<weight.length+1;i++){
              for(int j=weight[i-1];j<space+1;j++){
                  totalValue[j] = Math.max(totalValue[j],
                          totalValue[j - weight[i - 1]] + value[i - 1]);
              }
          }
          System.out.println("the total value is "+totalValue[space]);
      }
  ```

* **优化：**对于完全背包问题，可以看到每件物品的取值都在一个提前遇见的范围中，那么可以将其转化为01背包问题。也就是对于第i种物品，可以看成是有v/weight(i)件只能取或不取的具有相同重量、价值的物品。

###### 1.1.3 多重背包问题

* **问题：**有n件物品和容量为m的背包，给出每件物品的重量以及价值，且**每种物品有M(i)个**，求解让装入背包的物品重量不超过背包容量的最大总价值 。

* **分析：**思路和上面一样，转化为01背包

* **优化：**上面解法的时间复杂度为O(n\*sum(num))，可简化为O(n\*sum(log(num))

  对于第i种物品，有M(i)个，考虑分解为若干个物品，他们的重量和价值为原值乘一个系数。而这些系数分别是 1，2，2^2^，... ，2^k-1^，M(i)-2^k^+1，且k是满足M(i)-2^k^+1>0的最大整数。如M(i)=13，则k=1，2，4，6。这样用log(M(i))个物品代替原来拆分的M(i)个物品，并且0到M(i)之间的每一个整数都可由这些系数之和累加得到。降低了时间复杂度

* **程序代码：**

  ```java
  	public static void multiplePack(int space, int[] weight, int[] value, int[] num){
          int k = 1;
          int[] totalValue=new int[space+1];
          for(int i = 0; i<num.length;i++){
              //如果物品总重已经大于总容量，可以看成无限背包
              if(num[i]*weight[i]>space){
                  completePack_1(space, weight[i], value[i], totalValue);
              }else{
                  k=1;
                  while( k < num[i]){
                      pack01_1( space, k*weight[i], k*value[i], totalValue);
                      num[i] = num[i] - k;
                      k <<= 1;
                  }
                  //处理剩下不能被二整除的部分
                  pack01_1( space, num[i]*weight[i], num[i]*value[i], totalValue);
              }
          }
          System.out.println("the total value is "+totalValue[space]);
      }
  
      public static void completePack_1(int space, int weight, int value, int[] totalValue){
          for(int j=weight;j<space+1;j++){
              totalValue[j] = Math.max(totalValue[j],totalValue[j - weight] + value);
          }
      }
  
      public static void pack01_1(int space, int weight, int value, int[] totalValue){
          for(int j=space;j>=weight;j--){
              totalValue[j]=Math.max(totalValue[j],totalValue[j - weight] + value);
          }
      }
  ```

* **问题扩展：**

  若问题改为“不考虑总价值，问是否可以正好填满背包”

  > 类似问题，用n个不同的数，每种m个，是否可以累加得到K

  **分析：**定义dp\[n*k]矩阵，dp\[i][j]的值表示当用前i种物品刚好可以填满 j 容量的背包后剩余的第i种物品的个数，当值为-1时表示不可正好填满。

  可以知道，当前i种物品恰好装满 j 容量时，比然可以再装满 j+w(i) 的容量。

  那么，当用第i种物品，填充容量j时，有三种情况：

  1. dp\[i-1][j]>=0，说明前i-1种物品就可以填满了，自然有dp\[i][j]=m[i]；
  2. j<w(i) 或 dp\[i][j-w(i)]=-1 ，说明容量小于当前物品大小，或者容量j-w(i)时已经放不下，则有dp\[i][j]=-1;
  3. else， dp\[i][j]=dp\[i][j-w(i)]-1，前i种物品刚好放满 j-w(i) 容量时，自然可以放满j容量。

  **程序代码**

  ```java
  public static void isFullPack(int space, int[] weight, int[] num){
          int[][] dp = new int[weight.length+1][space+1];
          //初始化，零物品时只有零容量的值为0
          for(int j=0;j<space+1;j++){
              dp[0][j]=-1;
          }
          dp[0][0]=0;
          //
          for(int i=1;i<weight.length+1;i++){
              for(int j=0;j<space+1;j++){
                  if(dp[i-1][j]>=0){
                      dp[i][j]=num[i-1];
                  }else if(j<weight[i-1]||dp[i][j-weight[i-1]]==-1){
                      dp[i][j]=-1;
                  }else {
                      dp[i][j]=dp[i][j-weight[i-1]]-1;
                  }
              }
          }
          //如果可以恰好装满，则给出装填方法
         if(dp[weight.length][space]>=0) {
             int temp;
             for (int i = weight.length, j = space; i > 0 && j >= 0; i--) {
                 temp = num[i - 1] - dp[i][j];
                 System.out.println("the " + i + "th object : " + temp);
                 j -= temp * weight[i - 1];
             }
         }
      }
  ```

###### 1.1.4  二维费用背包问题

* **问题：**对于每件可选择的物品，有两种不同的费用，每种费用都有一个可付出的最大容量，那么如何选择物品使获得的价值最大。

* **分析：**与01背包相同，只不过价值矩阵加一个维度。状态转移方程如下：
  $$
  F(i,v)=max{\left [F(i-1,v,u),F(i-1,v-w1(i),u-w2(i))+v(i)\right ]}
  $$

* **问题拓展：**额外的费用通常以更加隐晦的方式给出，如限制可取的最大件数，这就相当于额外增加每件的费用为1，总体解决思路还应模仿01、完全、多重背包问题上靠。

###### 1.1.5 分组背包问题

* **问题：**所有可被选择的物品被分为K组，每组中物品互相冲突，最多选一件，该如何选择？

* **分析：**这个问题的选择策略变为：要么在这一组中选一件，要么跳过这一组，状态转移方程为
  $$
  F(i,v)=max{\left (F(k-1,v),\left [F(k-1,v-w(i))+v(i) \| i\in k\right ]\right )}
  $$

* 程序代码：

  ```java
      /**
       * @param space 背包容量
       * @param weight 同一行表示同一分组
       * @param value 与weight对应
       */
      public static void groupPack(int space, int[][] weight, int[][] value){
          int[] totalValue=new int[space+1];
          for(int k=0;k<weight.length;k++){
              for(int i=space;i>=0;i--){
                  for(int j=0;j<weight[k].length;j++) {
                      if(i>weight[k][j]) {
                          totalValue[i] = Math.max(totalValue[i], totalValue[i - 												weight[k][j]] + value[k][j]);
                      }
                  }
              }
          }
          System.out.println(totalValue[space]);
      }
  ```

* **优化：**当一组中存在 i，j 两个物品，i 比 j 重，且 j 比 i 价值更高，则直接跳过 i。

###### 1.1.6 背包问题的扩展

* 输出字典序最小的方案
* 输出方案总数
* 输出最优方案总数
* 求次优解、第K优解LeetCode

#### 410. 分割数组的最大值

> 给定一个非负整数数组和一个整数 m，你需要将这个数组分成 m 个非空的连续子数组。设计一个算法使得这 m 个子数组各自和的最大值最小。
> 注意: 数组长度 n 满足以下条件: 1 ≤ n ≤ 1000 1 ≤ m ≤ min(50, n) 
> 示例:
> 输入: nums = [7,2,5,10,8] m = 2 
> 输出: 18 
> 解释: 一共有四种方法将nums分割为2个子数组。
> 其中最好的方式是将其分为[7,2,5] 和 [10,8]， 因为此时这两个子数组各自的和的最大值为18，在所有情况中最小。

##### 解析：

* 解法一：动态规划

  动态规划的思路很简单，但算法复杂度较高

  当一个数组nums，已知其前j个数，分k-1组的子数组最大和为dp\[j][k-1]

  前i个数分为k组的子数组最大和dp\[i][k]=Math.max($dp[j][k-1]$,$\sum^{i-1}_{n=k-2}nums[n]$)，

  具体代码如下：

```Java
class Solution {

    public int splitArray(int[] nums, int m) {
        if(m==0){
            return 0;
        }
        int[][] dp = new int[nums.length][nums.length];
        for(int i=0;i<nums.length;i++){
            dp[i][i]=nums[i];
            for(int j=i+1;j<nums.length;j++){
                dp[i][j]=dp[i][j-1]+nums[j];
            }            
        }  
        if(m==1){        
            return dp[0][nums.length-1];
        }
        int[][] dpM = new int[nums.length][m+1];
        for(int i=0;i<nums.length;i++){
            dpM[i][1]=dp[0][i];
        }
        for(int k=2;k<=m;k++){
            for(int i=k-1;i<nums.length;i++){
                int res = Integer.MAX_VALUE;
                for( int j=k-2;j<=i-1;j++){
                    res=Math.min(res,Math.max(dpM[j][k-1],dp[j+1][i]));
                }
                dpM[i][k]=res;                
            }
        }
        return dpM[nums.length-1][m];
    }
}
```

解法二： 二分法

分析：

1. 首先，对于这个问题，数组nums如果按照一个数分一组，那么最大和即为max(nums)，如果所有数在同一组，那么最大和为sum(nums)，而这两个值也就是所有可能解的上下界；
2. 接着，选取一种中间值，按照这个中间值分组，使得每组和小于mid，且放入的元素最多，记录总分组数；
3. 最后如果分组数大于给定的分组数，那么说明每组装少了，需要增大下界；如果分组数小于等于给定的分组数，那么说明每组还能装更多的数，也就是减小上界。

具体逻辑见代码注释：

```java
public int splitArray(int[] nums, int m) {
        //二分法是一种基于假设最大值并搜索的方法找到的
        //max和min是最后结果所有可能值的上下限，如果可以一个数一组，那么结果是min，
    	//如果所有数一组，结果为max
        long min=0,max=0;
        //初始化min，max
        for(int i:nums){
            max+=i;
            if(i>min){
                min=i;
            }
        }
        long res = max;
        //开始搜索
        while(min<max){
            //这一轮循环认为每一组最大和为(min+max)/2
            long mid = (min+max)>>1;
            //sum存储每一组的和
            long sum=0;
            int group=1;
            for(int i: nums){
                //分组和超过了mid,则重新分一组
                if(sum+i>mid){
                    sum=i;
                    group++;
                }else{
                    sum+=i;
                }
            }
            //如果分组多了，那说明我们每组和小了，提高我们分组和范围的下界，
            //则可以让更多的数进入同一组
            if(group>m){
                min=mid+1;
            }else{
                //如果分组少了，那说明我们每组和大了，降低我们分组和范围的上界，
                //则可以让更少的数进入同一组
                res=Math.min(res,mid);
                max=mid-1;
            }
        }
        return (int)res;
    }
```

#### [818. 赛车](https://leetcode-cn.com/problems/race-car/)

**问题描述**：

> 你的赛车起始停留在位置 0，速度为 +1，正行驶在一个无限长的数轴上。（车也可以向负数方向行驶。）你的车会根据一系列由 A（加速）和 R（倒车）组成的指令进行自动驾驶 。
>
> 当车得到指令 "A" 时, 将会做出以下操作： position += speed, speed *= 2。
>
> 当车得到指令 "R" 时, 将会做出以下操作：如果当前速度是正数，则将车速调整为 speed = -1 ；否则将车速调整为 speed = 1。  (当前所处位置不变。)
>
> 例如，当得到一系列指令 "AAR" 后, 你的车将会走过位置 0->1->3->3，并且速度变化为 1->2->4->-1。
>
> 现在给定一个目标位置，请给出能够到达目标位置的最短指令列表的长度。
>
> 假设target为整数。

**问题分析**：

赛车只有两种运动指令，加速与倒车，由于target一定为正数，可以假设赛车开始指令一定是加速，可以得到一组指令形势即：AA...ARAA...ARAA...AR...，走过的路程一定是$(2^{k_1}-1)-(2^{k_2}-1)+(2^{k_3}-1)...$，

假设恰好走了$n$个A指令，走过的路程为$s=2^{n}-1$，此时：

* $s=target$，$dp[target]=n$；
* $s>target$，则要反向走$s-target$的距离，$dp[target]=min(dp[target]，n+1+dp[s-target])$；
* $s<target$，在反向走m步，最后再反向，则要对m遍历，m的范围应满足$2^m<s$，$dp[target]=min(dp[target],n+m+2+dp[target-(s-2^m-1)])$；

```java
/**
     * 从target=1时开始遍历：向前走s <= [0,2s]，分三种情况
     * @param target
     * @return
     */
    public int racecar(int target) {
        int[] dp = new int[10001];
        for (int i = 1;i <= target; i++){
            dp[i] = Integer.MAX_VALUE;
            for (int forword = 1;(1 << forword) - 1 < 2 * i; forword++) {
                int s = (1 << forword) - 1;
                if(s == i) {
                    dp[i] = forword;
                }else if (s > i) {
                    dp[i] = Math.min(dp[i], forword + 1 + dp[s - i]);
                }else {
                    for (int back = 0; back < forword; back++) {
                        int k = (1 << back) - 1;
                        dp[i] = Math.min(dp[i], forword + 1 + back + 1 + dp[i - s + k]);
                    }
                }
            }
        }
        return dp[target];
    }
```



### 2. KMP算法

注意next数组含义

```java
public class KMP {
    public static void main(String[] args) {
        char[] s = "ceabtcarbc".toCharArray();
        char[] p = "tcarb".toCharArray();


        System.out.println(kmp(s, p));
    }

    /**
     * KMP算法，求最大公共子串在原字符串的起始位置
     * @param s 原字符串
     * @param p 子字符串
     * @return
     */
    public static int kmp(char[] s,char[] p) {
        int i=0,j=0;
        int[] next= next(p);
        while (i<s.length&&j<p.length) {
            if (j==-1||s[i] == p[j]) {
                i++;
                j++;
            } else {
                j = next[j];
            }
        }
        if(j==p.length){
            return i-j;
        }
        return -1;
    }

    /**
     * 初始化Next数组
     * @param n
     * @return int[] n, next[i]表示长度为i字符串的最大相同前后缀数
     */
    public static int[] next(char[] n) {
        int[] next = new int[n.length];
        next[0] = -1;
        int k = -1;
        int j = 0;
        while (j<n.length-1) {
            if(k==-1||n[k]==n[j]) {
                k++;
                j++;
                if(n[k]!=n[j]) {
                    next[j] = k;
                }else {
                    next[j]=next[k];
                }
            }else {
                k=next[k];
            }
        }
        return next;
    }

}
```

### 3. LeetCode1156 : 单字符重复子串的最大长度

[1156. 单字符重复子串的最大长度](https://leetcode-cn.com/problems/swap-for-longest-repeated-character-substring/)

如果字符串中的所有字符都相同，那么这个字符串是单字符重复的字符串。
给你一个字符串 text，你只能交换其中两个字符一次或者什么都不做，然后得到一些单字符重复的子串。返回其中最长的子串的长度。

大致思路：
考虑一组字符串 s=“CDAABAABAAA”，其最长单字符重复子串必然是s[5]-s[10]，其中B被替换。
具体的，遍历时设一个指针start指向开始字符，一个指针cur指向当前字符，cur递加，那么

1. s[start]==s[cur]，说明重复，继续循环
2. s[start]!=s[cur]，这是因为可以选择交换一次字符，所以假设有可以被交换的字符，那么再设一个指针diff，其初始值为-1，指向第一个异与开始字符的下标diff=cur，此时：
   * 若diff==-1&&s[start]=s[cur+1]，说明交换的机会还没有被用掉，且从别的地方拉一个过来有用，继续循环；
   * 否则，说明要么没有机会交换了，或者交换了也连不起来

3. 这时就要退出这次的循环，开始找第二组重复字符串：
   * diff==-1，说明没交换过，start置为cur即可；
   * diff!=-1，start就从第一个不同的字符处再开始找，直到结束。

4. 在结束循环之前，还得保存这次循环找到的最大长度，即为len=cur-start，但是2中是假设有字符可以被交换，此时需要验证假设，显然如果len<当前循环中所匹配的字符的总个数，那么说明这个字符可以从别处调过来，否则，就要拿第一个或是最后一个抵上，此外如果这时diff==-1，说明没用到这个交换，如果还有空余字符，那么可以直接把它调到子串的最后面，len++。
5. 这说明我们最开始需要统计一遍所有字符的个数。

详细步骤见代码与注释：

```java
class Solution {
    public int maxRepOpt1(String text) {
        //如果字符串空则直接返回0
        if(text==null||"".equals(text)){return 0;}
        //变成数组方便计算
        char[] s=text.toCharArray();
        //建立数组统计字符个数
        int[] record = new int[26];
        //方便计算边界
        for(int i=0;i<s.length;i++){
            record[s[i]-'a']++;
        }
        //记录开始下标与当前下标
        int start=0,cur=1;
        int diff=-1;//记录第一个不同元素的index
        int len=1,maxLen=1;//保存结果
        //当前位置还在数组范围内时
        while(cur<s.length){
            if(s[cur]==s[start]){
                //如果相等，则cur往前走
                cur++;
                continue;
            }else if(diff==-1&&cur+1<s.length&&s[cur+1]==s[start]){
                //还没有交换过且交换有用
                diff=cur;
                cur++;
            }else{
                //计算长度
                len=cur-start;
                //分两种情况讨论，这里感觉没写好
                if(diff==-1) {
                    len += len < record[s[start] - 'a'] ? 1 : 0;
                }else {
                    len += len <= record[s[start] - 'a'] ? 0 : -1;
                }
                maxLen=Math.max(len,maxLen);
                //重置所有标识位
                start=diff==-1?cur:diff;
                cur=start+1;
                diff=-1;
            }
        }
        //如果最后一个字符没有进入else部分直接出来了，如“aaaa”，所有还要比较一下
        len=cur-start;
        if(diff==-1) {
            len += len < record[s[start] - 'a'] ? 1 : 0;
        }else {
            len += len <= record[s[start] - 'a'] ? 0 : -1;
        }
        return Math.max(len,maxLen);
    }
}
```

### 4. 最小生成树

Prim

### 5. TopK问题

* 解法1：改进的快排 O(n)

  ```java
  public int[] getLeastNumbers(int[] arr, int k) {
          if(arr.length<=k){return arr;}
          sort(arr,0,arr.length-1,k);
          return Arrays.copyOfRange(arr,0,k);
      }
  
      public void sort(int[] arr,int start, int end, int k){
          if(start>=end){return;}
          int flag = arr[start];
          int l=start,r=end;
          while(l<r){
              while(l<end&&arr[l]<=flag){
                  l++;
              }
              while(r>start&&arr[r]>=flag){
                  r--;
              }
              if(l>=r){
                  break;
              }
              int temp = arr[l];
              arr[l] = arr[r];
              arr[r] =temp;
          }
          arr[start]=arr[r];
          arr[r]=flag;
          if(r>=k-1){
              sort(arr,start,r,k);
          }else{
              sort(arr,l,end,k);
          }
      }
  ```

* 解法二：大顶堆

  ```java
  class Solution {
      public int[] getLeastNumbers(int[] arr, int k) {
          if (k == 0 || arr.length == 0) {
              return new int[0];
          }
          // 默认是小根堆，实现大根堆需要重写一下比较器。
          Queue<Integer> pq = new PriorityQueue<>((v1, v2) -> v2 - v1);
          for (int num: arr) {
              if (pq.size() < k) {
                  pq.offer(num);
              } else if (num < pq.peek()) {
                  pq.poll();
                  pq.offer(num);
              }
          }
          
          // 返回堆中的元素
          int[] res = new int[pq.size()];
          int idx = 0;
          for(int num: pq) {
              res[idx++] = num;
          }
          return res;
      }
  }
  ```

### 6. LeetCode 4：寻找两个有序数组的中位数

> 给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。
>
> 请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。
>
> 你可以假设 nums1 和 nums2 不会同时为空。

解析：考虑两个有序数组，长度m，n。找其中位数即是找其第$k=\frac{m+n}{2}$大的数。那么每次比较nums1[k/2]与nums2[k/2]的值，舍去小的那一部分，即可以每次筛去不符合题意的k/2个数。

```java
class Solution {
    public double findMedianSortedArrays(int[] nums1, int[] nums2) {
        int k1 = (nums1.length+nums2.length+1)>>1;
        int k2 = (nums1.length+nums2.length+2)>>1;
        return (findKth(nums1,0,nums1.length-1,nums2,0,nums2.length-1,k1)
                +findKth(nums1,0,nums1.length-1,nums2,0,nums2.length-1,k2))*0.5;
    }

    public double findKth(int[] nums1,int l1,int r1, int[] nums2, int l2, int r2,int k){
        if(l1>=nums1.length){
            return nums2[l2+k-1];
        }
        if(l2>=nums2.length){
            return nums1[l1+k-1];
        }
        if(k==1){
            return Math.min(nums1[l1],nums2[l2]);
        }
        int i1=Math.min(l1+k/2-1,nums1.length-1);
        int i2=Math.min(l2+k/2-1,nums2.length-1);
        int i=i1;
        if(nums1[i1]<nums2[i2]){
            k=k-(i1+1-l1);
            l1=i1+1;
        }else{
            k=k-(i2+1-l2);
            l2=i2+1;
            i=i2;
        }
        return findKth(nums1,l1,r1,nums2,l2,r2,k);
    }
}
```


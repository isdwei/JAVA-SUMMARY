## JVM复习笔记    JAVA Virtual Mechine

### JAVA内存区域与内存管理

<img src="C:\Users\weitu\AppData\Roaming\Typora\typora-user-images\1583499543544.png" alt="1583499543544" style="zoom:55%;" />

>   JVM 内存分哪几个区，每个区的作用是什么?  
>

运行时数据区：

* 程序计数器

  * 当前线程所执行字节码的行号指示器；
  * 空间线程私有，各线程有自己独立的程序计数器，互不干扰；
  * 执行Java方法时，计数器记录正在执行的字节码地址，执行本地方法时，计数器值为空（Undefined）,该区域不存在OOM。

* Java虚拟机栈

  * 栈帧存储局部变量（基本数据类型、引用类型和returnAdderss类型【指向一条字节码指令的地址】）、操作数栈、动态链接、方法出口信息；

  * 空间线程私有，各线程有自己独立的栈帧，每个线程栈的大小 -Xss  设置；

  * 线程请求的栈深度大于虚拟机所允许的深度：SOE（StackOverFlow Exception）；

    虚拟机栈动态扩展时无法申请到足够的内存：OOM（OutOfMemoryError）。

* 本地方法栈

  * 为虚拟机存储的Native方法服务。线程私有，（OOM，SOE也都存在）。

* Java堆

  * 存放对象实例，大小（-Xms，-Xmx）设置，OOM，线程共享
  * 新生代【伊甸区Eden，幸存区（Survivorfrom,Survivorto）】+老年代

* 方法区（永久代/元空间）

  * 已被虚拟机加载的类信息、常量、静态变量

  * 运行时常量池：（方法区的一部分）

    *  Byte,Short,Integer,Long,Character,Boolean种包装类默认创建了数值[-128，127]的相应类型的缓存数据，但是超出此范围仍然会去创建新的对象。 

    * String类型通过new创建会分配在堆中，通过“ ”创建分配在常量池中；

      由只包含“ ”创建的String和+组成的String会被存放在常量池中；

      String的intern()方法会查找常量池中是否存在一份equal相等的字符串，如果有则返回引用，如果没有则将自己添加如常量池

      > ```java
      > String s1 = new String("xyz"); //创建了几个对象？
      > ```
      
> "xyz"在类加载时已经创建于常量池，运行时将常量池的对象复制一份到堆中，引用交给s1持有。

* 直接内存（堆外内存）

  * 使用Native函数库直接使用本机内存，不受JVM限制，但也会存在OOM


### 垃圾收集器

> 如何判断对象需要回收？

* 引用计数算法：  给对象中添加一个引用计数器， 每当有一个地方引用它时， 计数器值就加1； 当引用失效时， 计数器值就减1； 任何时刻计数器为0的对象就是不可能再被使用的。  

  难以解决循环引用问题！（给个例子）

  ```java
  A.instance=B;
  B.instance=A;
  A=null;
  B=null;
  ```

* 可达性分析算法（Java，C#）：  当一个对象到GC Roots没有任何引用链相连时， 则证明此对象是不可用的。

  可以作为GCRoot的对象：

  * 虚拟机栈或本地方法栈中引用的对象；
  * 方法区中类静态属性或常量引用的对象。

### 强引用，软引用，弱引用和虚引用

<img src="C:\Users\weitu\AppData\Roaming\Typora\typora-user-images\1583487814854.png" alt="1583487814854" style="zoom: 67%;" />

* 强引用：不会被回收，Object obj = new Object()；

* 软引用：有用但并非必须，在即将OOM时会被回收，Java提供SoftReference类实现软引用，缓存；

* 弱引用：只能存活到下一次垃圾回收之前；

  > 用来解决ThreadLocal的threaLocal对象产生内存泄漏问题
  >
  > 但这不能根本解决，内存泄漏问题，必须调用remove方法解决

* 虚引用：无法通过虚引用取得一个对象实例，唯一作用在于虚引用关联的对象在被垃圾回收时会受到一个系统通知，PhantomReference类实现。通常用于堆外内存的管理，如NIO。

### 确定需要被回收的对象

> 不可达的对象都会被回收吗

一个对象的死亡至少经历两次标记的过程：

1. 可达性分析发现没有与GCRoot连接的引用，则会被第一次标记并进行一次筛选，筛选的条件时是否有必要执行finalize()方法。若对象没有覆盖finalize()方法或finalize() 方法已经被虚拟机调用过，则他们都被认为“没有必要执行”；
2. 对象被判定有必要执行finalize()后，会被放入F-Queue队列。GC会对F-Queue中的对象第二次标记，若对象在finalize()中重新被引用（如通过this被赋值），则会被移除处队列中。

- finalize()只会在对象内存回收前被调用一次(The finalize method is never invoked more than once by a Java virtual machine for any given object. )；
- finalize()不是析构函数，不建议使用（推荐try...finally...）

finalize()如何自我救赎：

* 对象覆写了finalize()方法（这样在被判死后才会调用此方法，才有机会做最后的救赎）；
* 在finalize()方法中重新引用到"GC  Roots"链上（如把当前对象的引用this赋值给某对象的类变量/成员变量，重新建立可达的引用）。

finalize()的调用具有不确定行，只保证方法会调用，但不保证方法里的任务会被执行完（比如一个对象手脚不够利索，磨磨叽叽，还在自救的过程中，被杀死回收了）。

### 安全点

程序执行时并非在所有地方都能停顿下来开始GC， 只有在到达安全点时才能暂停。 Safepoint的选定既不能太少以致于让GC等待时间太长， 也不能过于频繁以致于过分增大运行时的负荷。 所以， 安全点的选定基本上是以程序“ 是否具有让程序长时间执行的特征” 为标准进行选定的——因为每条指令执行的时间都非常短暂， 程序不太可能因为指令流长度太长这个原因而过长时间运行， “ 长时间执行” 的最明显特征就是指令序列复用， 例如方法调用、 循环跳转、 异常跳转等， 所以具有这些功能的指令才会产生Safepoint 。

对于Sefepoint， 另一个需要考虑的问题是如何在GC发生时让所有线程（ 这里不包括执行JNI调用的线程）都“ 跑” 到最近的安全点上再停顿下来。 这里有两种方案可供选择： 抢先式中断（ Preemptive Suspension） 和主动式中断（ Voluntary Suspension）

* 抢先式中断不需要线程的执行代码主动去配合， 在GC发生时， 首先把所有线程全部中断， 如果发现有线程中断的地方不在安全点上， 就恢复线程， 让它“ 跑” 到安全点上。

* 主动式中断的思想是当GC需要中断线程的时候， 不直接对线程操作， 仅仅简单地设置一个标志， 各个线程执行时主动去轮询这个标志， 发现中断标志为真时就自己中断挂起。 轮询标志的地方和安全点是重合的， 另外再加上创建对象需要分配内存的地方。

  如：当需要暂停线程时， 虚拟机把0x160100的内存页设置为不可读， 线程执行到test指令时就会产生一个自陷异常信号， 在预先注册的异常处理器中暂停线程实现等待， 这样一条汇编指令便完成安全点轮询和触发线程中断。    

### 回收方法区

> 方法区会发生垃圾回收吗

Java虚拟机规范中不要求虚拟机回收方法区。

方法区的回收包括：废弃常量和无用的类

* 判断废弃常量也是可达性分析
* 判断无用的类：
  * 该类所有实例被回收
  * 加载该类的ClassLoader被回收
  * 该类对应的java.lang.Class对象没有被引用，无法通过反射访问该类的方法

> 对与大量使用反射、动态代理的框架，频繁自定义ClassLoader的场景都需要虚拟机具备类卸载功能，保证方法区不会溢出。

### 垃圾收集算法

#### 标记清除算法（Mark-Sweep）

首先标记处需要回收的对象（见4），再统一回收所有被标记的对象。

特点：

* 效率低（标记和清除过程效率都低）；
* 会产生大量不连续的空间碎片。

#### 复制算法（Copying）

将可用内存按容量划分为两块，每次只是用一块。当这块内存用完了，就将活着的对象复制到另一块，已使用的内存空间一次性清理掉。

特点：

* 无内存碎片，简单高效；
* 内存缩小为一半，代价较高。

#### 标记整理算法（Mark-Compact）

标记需要回收的对象，将所有存活的对象向一端移动，直接清理掉边界外的内存。

特点：

* 没有内存碎片
* 需要移动对象的成本

#### 分代收集算法

### 垃圾收集器

* Serial收集器（新生代，老年代有不同的版本）

  * 新生代（Serial New）复制算法，老年代(Serial Old)采用标记-整理算法；
  * 单线程，工作时会暂停其他所有工作线程（“Stop The World”）。
  * 开启参数： -XX: +UseSerialGC 开启后新生代使用Serial New，老年代使用Serial Old。

* ParNew收集器 (即Parallel for New Generation)

  * 多线程工作，原理与Serial一样

  * 开启参数： -XX: +UseParNewGC ，开启后新生代使用ParNew（复制算法），老年代使用Serial Old（标记-整理算法），默认开启与CPU数目相同的线程数。

    这种组合JDK8中已被deprecated。

* Parallel Scavenge收集器（新生代）

  * 多线程工作，吞吐量优先原则；
  * 自适应调节策略：虚拟机会根据当前系统运行情况动态调整参数来提供最合适的停顿时间或最大吞吐量；
  * 开启参数：-XX: +UseParallelGC或-XX：+UseParallelOldGC，新生代复制算法，老年代使用ParOld收集器（标记-整理算法）

* 并发标记清除垃圾收集器（CMS，Concurrent Mark Sweep）

  * 用户线程和垃圾收集线程同时执行（并发，可能是交替执行），目的是获得最短停顿时间；

    会产生内存碎片；

  * 采用标记-清除算法；

  * 开启参数：+XX: +UseConcMarkSweeoGC，开启后新生代使用ParNew，老年代使用CMS（Serial Old作为后备收集器）

  * 初始标记(Stop) ---> 并发标记(并发) ---> 重新标记(Stop)- ----> 并发清除（并发）

    ![1583497124691](C:\Users\weitu\AppData\Roaming\Typora\typora-user-images\1583497124691.png)
    
    **CMS收集器无法处理浮动垃圾（ Floating Garbage） ， 可能出现“ Concurrent Mode Failure” 失败而导致另一次Full GC的产生。**
    
    浮动垃圾是指：由于CMS并发清理阶段用户线程还在运行着， 伴随程序运行自然就还会有新的垃圾不断产生， 这一部分垃圾出现在标记过程之后， CMS无法在当次收集中处理掉它们， 只好留待下一次GC时再清理掉。
    
    也是由于在垃圾收集阶段用户线程还需要运行， 那也就还需要预留有足够的内存空间给用户线程使用， 因此CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集， 需要预留一部分空间提供并发收集时的程序运作使用。 在JDK 1.5的默认设置下， CMS收集器当老年代使用了68%的空间后就会被激活，在JDK1.6中， CMS收集器的启动阈值已经提升至92%。 要是CMS运行期间预留的内存无法满足程序需要， 就会出现一次“ Concurrent Mode Failure” 失败， 这时虚拟机将启动后备预案： 临时启用Serial Old收集器来重新进行老年代的垃圾收集， 这样停顿时间就很长了。

* G1垃圾收集器 见9

> 如何选择垃圾收集器?
>
> 单CPU，小内存：SerialGC
>
> 多CPU，大吞吐量：ParallelScavenge
>
> 多CPU，快速响应：CMS

### 内存分配与回收策略

<img src="C:\Users\weitu\AppData\Roaming\Typora\typora-user-images\1583501265277.png" alt="1583501265277" style="zoom: 50%;" />

* 内存分配：

  * 堆内存分为新生代和老年代（默认1：2）
  * 新生代分为两部分：伊甸区和幸存区（幸存0区，幸存1区）（默认8：1：1）；

* 回收策略：

  * 新建对象优先在新生代Eden区分配；

  * 大的对象直接放在老年代；

  * Eden区空间不够时会发生Minor GC：

    > Minor GC的过程：复制—>清空—>互换

    * Eden区满时触发第一次Minor GC，活着的对象拷贝到SurvivorFrom区；
    * Eden区再次满时，再次触发Minor GC，将Eden区和From区活着的对象拷贝至To区，同时把这些对象的年龄+1；
    * 清空Eden和From区，将From区与To区互换；
    * 若一个对象（默认）交换15次后依旧存活，进入老年代。（年龄参数 MaxTenuringThreshold决定）

  * 老年代内存满时Full GC/Major GC，Full GC 发生时必定伴随Minor GC。

### G1垃圾回收器

* 特点：
  * 适合多CPU，大内存环境，能尽量缩短STW; 
  * 整体上标记-整理算法，局部复制算法，无内存碎片
  * 把内存划分为独立的子区域，每个区域保留新生代和老年代的区别，但不要求内存连续，每个区域可随着G1运行改变自己的角色，垃圾回收时避免了全内存扫描；

* 原理：

  ![1583509016437](C:\Users\weitu\AppData\Roaming\Typora\typora-user-images\1583509016437.png)

  G1收集器将堆分割成多个子区域（默认2014个分区），每个区域大小为2的整数次幂（-XX：G1HeapRegionSize=n，1MB~32MB），只有逻辑上的分代概念，物理上不再隔离（每个分区都可能随G1的运行在不同代之间切换）。

  Eden区耗尽时触发垃圾回收，暂停所有进程，并形成连续内存块；

  * Eden区数据移动到Survivor区，若Survivor区空间不够，则Eden区数据全部晋升Old区；
  * Survivor区数据移动到新的Survivor区，部分数据晋升Old区；
  * 最后Eden区收集完，GC结束

  在G1收集器中， Region之间的对象引用以及其他收集器中的新生代与老年代之间的对象引用， 虚拟机都是使用Remembered Set来避免全堆扫描的。 G1中每个Region都有一个与之对应的Remembered Set， 虚拟机发现程序在对Reference类型的数据进行写操作时， 会产生一个Write Barrier暂时中断写操作， 检查Reference引用的对象是否处于不同的Region之中（ 在分代的例子中就是检查是否老年代中的对象引用了新生代中的对象） ， 如果是， 便通过CardTable把相关引用信息记录到被引用对象所属的Region的Remembered Set之中。 当进行内存回收时， 在GC根节点的枚举范围中加入Remembered Set即可保证不对全堆扫描也不会有遗漏 。

* 优点（与CMS相比）

  * 并发回收，整体上采用标记整理算法，局部采用复制算法。避免了全内存扫描，只需按照区域扫描；

  * 可以控制停顿时间，每次根据允许停顿的时间去收集垃圾最多的区域。

* 开启参数： XX: +UseG1GC

### 虚拟机的加载机制

* 类的生命周期

  <img src="C:\Users\weitu\AppData\Roaming\Typora\typora-user-images\1583732055511.png" alt="1583732055511" style="zoom: 33%;" />

  类的加载过程：

  1. 加载：将类的c读取如内存，并存放在方法区；
  2. 验证：确保Class文件的字节流符合虚拟机要求；
  3. 准备：为类变量（static）分配内存设置初始值(0,ture,null)，如果类变量时final修饰，则赋给定值；
  4. 解析 ：将常量池中的符号替换为直接引用；
  5. 初始化：执行初始化代码

* 类的加载顺序：

  对于static关键字，他修饰的属性或方法是可以通过类来访问，当class文件被加载进内存开始初始化时，static变量/方法即被分配了内存，其他变量是在对象被创建后，才被分配内存的。所以在类中，加载顺序为：

  1. 首先加载父类的静态字段或者静态语句块

  2. 子类的静态字段或静态语句块

  //如果创建一个类的实例会继续执行以下：

  3. 父类普通变量以及语句块

  4. 父类构造方法被加载

  5. 子类变量或者语句块被加载

  6. 子类构造方法被加载

* 类的初始化时机（即初始化类的静态变量，执行类的静态初始化方法）

  1. 创建类的实例，也就是new一个对象 ；
  2. 访问某个类或接口的静态变量、静态方法，或者对该静态变量赋值 ；
  3. 反射（Class.forName(“  ”)）；
  4. 初始化一个类的子类（会首先初始化子类的父类）； 
  5. JVM启动时标明的启动类，即文件名和类名相同的那个类  ；
  6.  当使用 JDK 1.7 的动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需先触发其初始化。 

  不会初始化类的情况

  1. 子类引用父类的静态字段，不会导致子类初始化；
  2. 通过数组定义来引用类，不会触发类的初始化；
  3. 引用一个类的常量，不会触发类的初始化。

* 类加载器

  * 双亲委派模型：  为了避免代码污染Java自带的程序，提供一种双亲委派机制以满足沙箱安全。

    如果一个类加载器收到了类加载的请求， 它首先不会自己去尝试加载这个类， 而是把这个请求委派给父类加载器去完成， 每一个层次的类加载器都是如此， 因此所有的加载请求最终都应该传送到顶层的启动类加载器中， 只有当父加载器反馈自己无法完成这个加载请求（ 它的搜索范围中没有找到所需的类）时， 子加载器才会尝试自己去加载  。

  * 四类加载器

    启动类加载器（BootStrap ClassLoader） C++编写，java自带的类，JAVA_HOME/lib

    扩展类加载器（Extension ClassLoader）java后续增加的类，JAVA_HOME/lib/ext

    应用程序类加载器（Application ClassLoader）加载ClassPath路径上所指定的类库（默认类加载器）

    自定义类加载器（User ClassLoader)

    <img src="C:\Users\weitu\AppData\Roaming\Typora\typora-user-images\1583737170987.png" alt="1583737170987" style="zoom: 33%;" />

  





###  一些问题

* **STW是立即停止用户线程吗?为什么CMS要两次STW？**

Stop The World（停顿类型STW）

  **我们知道垃圾回收首先是要经过标记的。对象被标记后就会根据不同的区域采用不同的收集方法。看上去很完美的一件事情，其实并不然。** 
  大家有没有想过一件事情，当虚拟机完成两次标记后，便确认了可以回收的对象。但是，**垃圾回收并不会阻塞我们程序的线程，他是与当前程序并发执行的**。所以问题就出在这里，**当GC线程标记好了一个对象的时候，此时我们程序的线程又将该对象重新加入了“关系网”中，当执行二次标记的时候，该对象也没有重写finalize()方法，因此回收的时候就会回收这个不该回收的对象。** 
  **虚拟机的解决方法就是在一些特定指令位置设置一些“安全点”，当程序运行到这些“安全点”的时候就会暂停所有当前运行的线程（Stop The World 所以叫STW），暂停后再找到“GC Roots”进行关系的组建，进而执行标记和清除。** 

这些特定的指令**（安全点）位置主要在**：

- 循环的末尾
- 方法临返回前 / 调用方法的call指令后
- 可能抛异常的位置

  找到“GC Roots”也是要花很长的时间，然而这里又有新的解决方法，就是通过**采用一个OopMap的数据结构来记录系统中存活的“GC Roots”**，在类加载完成的时候，虚拟机就把对象内什么偏移量上是什么类型的数据计算出来保存在OopMap，通过解释OopMap就可以找到堆中的对象，这些对象就是GC Roots。而不需要一个一个的去判断某个内存位置的值是不是引用。这种方式也叫准确式GC。 
  回到最开始的问题，那个**停顿类型就是STW**，至于**有GC**和**Full GC**之分，还有**Full GC (System)**。个人认为主要是Full GC时STW的时间相对GC来说时间很长，因为Full GC针对整个堆以及永久代的，因此整个GC的范围大大增加；还有就是他的回收算法就是我们之前说过的“标记–清除–整理”，这里也会损耗一定的时间。**所以我们在优化JVM的时候，减少Full GC的次数也是经常用到的办法。** 
  本文篇幅较短，主要为下一章要讲的收集器打下基石，各位只要知道GC之前还有STW这一步骤和知道OopMap以及安全点的存在即可。

### JVM调优

* -XX：+/- boolean类型参数，表示开启或关闭某个类型参数。

  例如：-XX：+PrintGCDetails

  ​			-XX：+UseSerialGC

* -XX：属性key=属性值value

  例如：-XX：MetaspaceSize=128m

  ​			-XX：MaxTenuringThreshold=15

  两个经典参数 -Xms 即 -XX：InitialHeapSize

  ​						-Xmx 即 -XX：MaxHeapSize 

  ​						-Xss 即 -XX：ThreadStackSize

* 生产环境服务器性能变慢
  * 整机 top
  * CPU vmstat
  * 内存 free
  * 磁盘IO iostat   网络IO  ifstat

* CPU占用过高怎么办
  * 首先top看CPU占比最高的
  * ps -ef 或 jps 进一步定位
  * 定位到具体的线程或代码 ps -mp 进程 -o THREAD,tis,time
  * jstack 进程ID | grep tid(16进制线程ID) -A60

### JVM工具

* jinfo -flag 配置项 进程编号 //查某个JVM中进程的配置参数
* jps 虚拟机进程状况工具
* jmap 内存映像工具
* jstat 统计信息监控工具



